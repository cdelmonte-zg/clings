format_version = 1
default_compiler = "gcc"

welcome_message = """
       _ _
   ___| (_)_ __   __ _ ___
  / __| | | '_ \\ / _` / __|
 | (__| | | | | | (_| \\__ \\
  \\___|_|_|_| |_|\\__, |___/
                  |___/

  Welcome to clings! ðŸ”§

  This project contains small exercises to help you learn
  advanced C concepts by fixing broken code and implementing
  missing functionality.

  How it works:
  - Each exercise has a bug or a TODO for you to fix
  - Edit the .c file in your editor
  - clings will automatically recompile and verify your changes

  Commands: [n]ext [h]int [l]ist [r]e-run [q]uit
"""

final_message = """
  Congratulations! You've completed all exercises! ðŸŽ‰
  You now have a deeper understanding of advanced C concepts.
"""

# â”€â”€ 00: Intro â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

[[exercises]]
name = "intro1"
dir = "00_intro"
test = false
sanitizers = false
hint = """
This is your first exercise! Just read the code and fix the TODO.
The program should print a welcome message and exit with code 0.
"""

# â”€â”€ 01: Pointers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

[[exercises]]
name = "pointers1"
dir = "01_pointers"
test = true
sanitizers = true
hint = """
When you pass an array to a function in C, it "decays" to a pointer.
This means sizeof() inside the function gives you the pointer size,
not the array size. You need to pass the size as a separate parameter.
"""

[[exercises]]
name = "pointers2"
dir = "01_pointers"
test = true
sanitizers = true
hint = """
Pointer arithmetic moves by the size of the pointed-to type.
If `int *p` points to an array, then `p + 1` points to the next int,
not the next byte. Think about what `*(p + i)` is equivalent to.
"""

# â”€â”€ 02: Memory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

[[exercises]]
name = "memory1"
dir = "02_memory"
test = true
sanitizers = true
hint = """
Every malloc() must have a matching free().
But be careful about the ORDER of operations:
- Don't use memory after freeing it (use-after-free)
- Don't free the same pointer twice (double-free)
- Don't forget to free at all (memory leak)

Think about: what should you free first when you have nested allocations?
"""

# â”€â”€ 03: Undefined Behavior â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

[[exercises]]
name = "ub1"
dir = "03_undefined_behavior"
test = true
sanitizers = false
hint = """
Signed integer overflow is undefined behavior in C!
The compiler is free to assume it never happens.
This means `if (x + 1 > x)` can be optimized away.

To safely check for overflow, you need to check BEFORE the operation.
Compare against INT_MAX or INT_MIN instead.
"""

# â”€â”€ 04: Preprocessor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

[[exercises]]
name = "preprocessor1"
dir = "04_preprocessor"
test = true
sanitizers = false
hint = """
The # operator in a macro "stringifies" its argument, turning it into
a string literal. For example:
  #define STR(x) #x
  STR(hello)  // becomes "hello"

The ## operator concatenates two tokens:
  #define CONCAT(a, b) a##b
  CONCAT(foo, bar)  // becomes foobar
"""

# â”€â”€ 05: UB Lab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#
# These exercises look correct but contain subtle undefined behavior.
# They compile and "work" on most systems, but sanitizers catch them.
# Your task: identify and fix the UB.

[[exercises]]
name = "ub_lab1"
dir = "05_ub_lab"
test = true
sanitizers = true
hint = """
Left-shifting a 1 into the sign bit of a signed int is UB in C11.
`1 << 31` is undefined when int is 32 bits.

The fix is simple: use an unsigned literal.
`1u << 31` is well-defined because unsigned overflow wraps.
"""

[[exercises]]
name = "ub_lab2"
dir = "05_ub_lab"
test = true
sanitizers = true
hint = """
Casting between unrelated pointer types violates the strict aliasing
rule (C11 6.5p7). The compiler assumes pointers of different types
don't alias, and may reorder or eliminate loads/stores.

Use memcpy() to safely reinterpret bytes between types.
This is the standard-blessed way to do type punning in C.
"""

[[exercises]]
name = "ub_lab3"
dir = "05_ub_lab"
test = true
sanitizers = true
hint = """
After realloc(), the old pointer is invalidated â€” even if realloc
returns the same address, you can't rely on that.

Any pointer into the old block is now dangling.
Save the INDEX, not the pointer, and recalculate after realloc.
"""

[[exercises]]
name = "ub_lab4"
dir = "05_ub_lab"
test = true
sanitizers = true
hint = """
Signed integer overflow during multiplication is UB.
For factorial(13), the result exceeds INT_MAX.

Check BEFORE multiplying: if (result > INT_MAX / i) then overflow.
Or use a wider type (long long) if the range is sufficient.
"""

[[exercises]]
name = "ub_lab5"
dir = "05_ub_lab"
test = true
sanitizers = true
hint = """
malloc() returns uninitialized memory. Reading an uninitialized
field is undefined behavior â€” even if it "happens to be zero."

Use calloc() to zero-initialize, or explicitly set every field
after malloc(). memset(ptr, 0, size) also works.
"""

[[exercises]]
name = "ub_lab6"
dir = "05_ub_lab"
test = true
sanitizers = true
hint = """
Off-by-one errors in array indexing cause out-of-bounds access.
Reading past the end of an array is UB, even if it "works."

Check your loop bounds: should it be `< size` or `<= size`?
And when allocating strings, don't forget space for the null terminator.
"""
